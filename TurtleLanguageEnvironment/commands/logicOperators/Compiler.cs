using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TurtleLanguageEnvironment.commands.logicOperators
{
	/// <summary>
	/// This class is intendeds to expand on the scripting capabilities of Part 1's features by giving the user the ability to use
	/// more programming logic usages such as the ability to make variables, methods, if statements and loops (both while and for loops).
	/// </summary>
	class Compiler
	{
		private List<String> compiledCode = new List<String>();
		private Factory logicCreator = new Factory();
		private List<Method> functionList = new List<Method>();
		private List<Variable> variableList = new List<Variable>();
		private List<IfStatement> ifList = new List<IfStatement>();
		private int programCounter = 0;

		private int loopCounter = 0;
		private bool loopFlag = false;
		private int loopSize = 0;

		private int variablecounter = 0;

		private int methodCounter = 0;
		private bool methodFlag = false;
		private bool methodExecuting = false;
		private int saveProgramCounter = 0;
		private bool executeLinesFlag = true;
		private int iteraton = 0;
		private string line;

		private string[] split;
		private string command;
		private string parameter;

		/// <summary>
		/// This method generates the compiled code. In a practical use, the compiled code generated by this method is code that turns all the logic into understable code for the Parser class.
		/// </summary>
		/// <param name="lines"> The Lines variable is an array of the user's input line by line. It contains logic (e.g ifs and loops) </param>
		/// <returns>This returns a compiled version of the user typed program that turns the logic to understandable commands by part 1's parser.</returns>
		public List<String> getCompiledCode(String[] lines)
		{
			while (programCounter < lines.Length)
			{
				line = lines[programCounter].ToLower();
				split = line.Split(' ');

				try
				{
					command = split[0];
				}
				catch (Exception e)
				{
					command = null;
				}
				try
				{
					parameter = split[1];
				}
				catch (Exception e)
				{
					parameter = null;
				}

				IEnumerable<Variable> query = variableList.Where(p => p.GetName() == command);

				if (query != null)
				{
					foreach (Variable var in query)
					{
						var.setOperation(parameter);
						var.runEquation(split[2]);
					}

					for (int x = 0; x < (split.Length); x++)
					{
						// CALL VARIABLE VALUES
						foreach (Variable var in variableList)
						{
							if (split[x] == var.GetName())
							{
								line = line.Replace(split[x], var.GetValue());
								split[x] = var.GetValue();
							}
						}
					}
				}

				// check syntax
				if (methodFlag == false && executeLinesFlag == true) // Checks if the code is meant to be running or not
				{

					if (command == "function") // creates a method
					{
						//HANDLE METHODS
						functionList.Add((Method)logicCreator.createMethod(parameter, (programCounter).ToString()));
						methodFlag = true;
					}
					else if (command == "call")
					{
						methodCounter = 0;
						foreach (Method element in functionList)
						{
							if (element.GetName() == parameter)
							{
								programCounter += 1;
								saveProgramCounter = programCounter;
								programCounter = element.GetPointer();
								methodExecuting = true;
							}
							methodCounter++;
						}
					}
					else if (methodExecuting == true && command == "endfunction") // If a method is running, check for the finish.
					{
						programCounter = saveProgramCounter;
						methodExecuting = false;

					}


					else if (command == "var") //IF ITS A VARIABLE
					{
						// add stuf to check if variable exists
						variableList.Add(logicCreator.createVarariable(split[1], split[3]));
					}

					// FOR LOOP LOGIC
					else if (command == "for")
					{
						iteraton = int.Parse(parameter);
						loopFlag = true;
						loopCounter = 0;
						loopSize = 0;
					}
					else if (command == "endfor")
					{
						if (loopFlag == true)
						{
							loopFlag = false;
							loopCounter++;
							if (loopCounter < iteraton)
							{
								programCounter = programCounter - loopCounter;
							}
						}
					}

					// WHILE LOOP LOGIC
					else if (command == "while")
					{
						loopFlag = true;
						loopCounter = 0;
						loopSize = 0;
						// uses if statement to loop around
						string polishedParams = split[1] + "," + split[3];
						IfStatement tempIfWhile = (IfStatement)logicCreator.createIfStatement(split[2], polishedParams);
						bool temp = tempIfWhile.checkStatement();
						if (!temp) // Checks if the if statement is false
						{
							loopFlag = false;
						}
					}
					else if (command == "endwhile")
					{
						if (loopFlag == true)
						{
							loopFlag = false;
							loopCounter++;
							if (loopFlag == false)
							{
								programCounter = programCounter - loopCounter;
							}
						}
					}


					// IF STATEMENT LOGIC
					else if (command == "if")
					{
						string polishedParams = split[1] + "," + split[3];
						Console.WriteLine(polishedParams);
						Console.WriteLine(split[2]);
						IfStatement tempIf = (IfStatement)logicCreator.createIfStatement(split[2], polishedParams);
						bool temp = tempIf.checkStatement();
						if (!temp) // Checks if the if statement is false
						{
							executeLinesFlag = false;
						}

					}
					else // If its a normal command
					{
						if (!(command == "endif" || command == "endfunction"))
						{
							//Console.WriteLine(line);
							compiledCode.Add(line);
						}
					}
					if (loopFlag == true)
					{
						loopSize++;
					}
				}
				else if (methodFlag == true && command == "endfunction") // checks for the end of the method.
				{
					methodFlag = false;
				}
				else if (executeLinesFlag == false && command == "endif")
				{
					executeLinesFlag = true;
				}

				programCounter++;

			}
			return compiledCode;
		}
	}

}


